# HomeworkDesign
## Диаграмма классов
![image](https://github.com/user-attachments/assets/a64b6458-11af-4078-877f-14c5ee452139)


Описание каждого класса
ActiveOrderState
Класс реализует интерфейс IOrderState и отвечает за обработку активного состояния заказа. В методе HandleOrder, когда заказ активен, выводится сообщение о готовности заказа к доставке, а состояние заказа меняется на доставленный (new DeliveredOrderState()).

### Cart
Класс представляет корзину пользователя. Содержит список продуктов, добавленных в корзину. Методы AddProduct и DisplayCart добавляют продукт в корзину и отображают содержимое корзины соответственно.

### DeliveredOrderState
Реализация интерфейса IOrderState. Обрабатывает состояние доставки заказа. Метод HandleOrder выводит сообщение о том, что заказ был доставлен.

### Dress
Конкретная реализация абстрактного класса Product. Представляет платье. Реализует метод DisplayDetails, который выводит информацию о названии платья и его цене.

### DressFactory
Конкретная реализация абстрактного класса ProductFactory. Создает объекты типа Dress.

### InactiveOrderState
Реализация интерфейса IOrderState. Отвечает за неактивное состояние заказа. При вызове метода HandleOrder меняет состояние заказа на активное (new ActiveOrderState()) и выводит соответствующее сообщение.

### IObserver
Интерфейс наблюдателя. Определяет метод Update, который должен быть реализован всеми классами, наблюдающими за изменениями объекта.

### IOrderState
Интерфейс состояния заказа. Определяет метод HandleOrder, который обрабатывается в зависимости от текущего состояния заказа.

### Order
Основной класс, представляющий заказ. Хранит текущее состояние заказа (_state), которое изменяется методами SetState и Handle. Изначально создается с состоянием InactiveOrderState.

### OrderNotifier
Класс уведомителя заказов. Реализует шаблон Наблюдатель (Observer). Хранит список подписчиков (наблюдателей) и методы для подписки, отписки и уведомления всех подписчиков о состоянии заказа.

### Product
Абстрактный базовый класс для всех товаров. Имеет свойства Name и Price, а также абстрактный метод DisplayDetails, который должен быть переопределен в конкретных подклассах.

### ProductFactory
Абстрактный класс фабрики продуктов. Определяет метод CreateProduct, который создает конкретный тип продукта.

### Shirt
Конкретная реализация абстрактного класса Product. Представляет рубашку. Реализует метод DisplayDetails, который выводит информацию о названии рубашки и ее цене.

### ShirtFactory
Конкретная реализация абстрактного класса ProductFactory. Создает объекты типа Shirt.

### Шаблон проектирования Observer (Наблюдатель)
Шаблон Observer используется для создания отношений "один ко многим", где одно изменение в объекте приводит к изменению во многих зависимых объектах. В данном примере этот паттерн применяется в классе OrderNotifier, который хранит список наблюдателей (подписчиков) и уведомляет их о изменениях состояния заказа.

Применение:В контексте оформления заказа в интернет-магазине важно, чтобы система могла своевременно информировать пользователей о статусе их заказа. Например, пользователь может получать уведомления о том, что его заказ принят, отправлен или доставлен. Использование шаблона Observer позволяет гибко управлять этими уведомлениями, позволяя различным объектам подписываться на изменения статуса заказа и реагировать соответствующим образом.

### Шаблон проектирования Factory Method (Фабричный метод)
Шаблон Factory Method определяет интерфейс для создания объектов, но оставляет подклассам решение о том, какой именно объект создать. В нашем примере этот паттерн используется в абстрактном классе ProductFactory и его конкретными реализациями DressFactory и ShirtFactory.

Применение:При оформлении заказа в интернет-магазине одежда может включать разные виды продукции, например, платья и рубашки. Вместо того чтобы жестко закодировать создание конкретного вида товара, мы используем фабрику, которая возвращает нужный экземпляр продукта на основании переданных параметров. Это делает систему более расширяемой и гибкой, поскольку новые продукты могут быть добавлены без изменения основного кода.

## Заключение
Представленная архитектура кода демонстрирует грамотное использование принципов объектно-ориентированного программирования и шаблонов проектирования GoF. Применение шаблонов Observer и Factory Method позволило сделать систему оформления заказа более гибкой и расширяемой.

Использование Observer обеспечивает динамическое уведомление заинтересованных сторон о состоянии заказа, что важно для своевременной реакции на изменения. Фабрика продуктов упрощает создание различных видов товаров, делая систему менее подверженной изменениям при добавлении новых типов продукции.
